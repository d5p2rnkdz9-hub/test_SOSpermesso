---
phase: 02-adaptive-logic-results
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - prisma/seed.ts
  - src/store/quiz-store.ts
  - src/hooks/useQuiz.ts
  - src/types/quiz.ts
autonomous: true

must_haves:
  truths:
    - "Different users see different question paths based on their answers"
    - "Users who have used AI for work see deeper follow-up questions about their usage"
    - "Users who have NOT used AI see questions about barriers and interest level"
    - "The quiz path length varies naturally between users (not fixed count)"
    - "Question flow covers: experience, satisfaction, concerns, expectations"
  artifacts:
    - path: "prisma/seed.ts"
      provides: "Full adaptive question set with branching logic"
      contains: "nextQuestionId"
    - path: "prisma/schema.prisma"
      provides: "Session model with coursePrompts and facilitatorNotes fields"
      contains: "coursePrompts"
    - path: "src/store/quiz-store.ts"
      provides: "Branching engine supporting nextQuestionId jumps"
      contains: "nextQuestionId"
    - path: "src/hooks/useQuiz.ts"
      provides: "Updated visible questions calculation for branching"
  key_links:
    - from: "prisma/seed.ts"
      to: "src/store/quiz-store.ts"
      via: "Question options with nextQuestionId drive navigation"
      pattern: "nextQuestionId"
    - from: "src/store/quiz-store.ts"
      to: "src/hooks/useQuiz.ts"
      via: "Store nextQuestion uses option-level branching"
      pattern: "nextQuestionId"
---

<objective>
Replace the Phase 1 question set with a fully adaptive questionnaire and upgrade the branching engine to support per-answer navigation jumps.

Purpose: The current quiz only branches on Q2 (yes/no). Phase 2 needs every question to potentially branch based on the selected answer, creating natural adaptive paths through experience, satisfaction, concerns, and expectations domains.

Output:
- New seed data with ~15-20 Italian questions organized into adaptive branching paths
- Schema update adding coursePrompts and facilitatorNotes to Session model
- Quiz store branching engine upgraded to support option-level nextQuestionId
- useQuiz hook updated for new branching behavior
</objective>

<execution_context>
@/Users/albertopasquero/.claude/get-shit-done/workflows/execute-plan.md
@/Users/albertopasquero/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-adaptive-logic-results/02-CONTEXT.md
@prisma/schema.prisma
@prisma/seed.ts
@src/store/quiz-store.ts
@src/hooks/useQuiz.ts
@src/types/quiz.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schema update + new adaptive question data</name>
  <files>prisma/schema.prisma, prisma/seed.ts, src/types/quiz.ts</files>
  <action>
  **Schema changes (prisma/schema.prisma):**
  Add two new fields to the Session model:
  - `coursePrompts Json?` - stores array of personalized course prompts for participant
  - `facilitatorNotes String?` - stores facilitator summary of what this participant needs

  Run `npx prisma db push` to apply changes (no migration needed for dev).

  **Types update (src/types/quiz.ts):**
  Add `coursePrompts` and `facilitatorNotes` to the Session interface.
  Add a `CoursePrompt` interface: `{ text: string; category: string }`.
  Add a `FeedbackWithPrompts` API response type that includes feedback text, coursePrompts array, and facilitatorNotes.

  **New seed data (prisma/seed.ts):**
  Replace existing questions with a fully adaptive question set. All text in Italian. The flow structure:

  **Section 1: Experience (adaptive depth)**
  - Q1: "Hai mai sentito parlare di strumenti di intelligenza artificiale come ChatGPT, Claude o Gemini?" (YES_NO)
    - If NO -> jump to Q1b (awareness baseline)
    - If YES -> continue to Q1a
  - Q1a: "Quali strumenti AI hai provato?" (MULTIPLE_CHOICE: ChatGPT, Claude, Gemini, Copilot, Banca dati giuridica con AI, Altro)
    - Continue to Q2
  - Q1b: "Come mai non li hai ancora provati?" (SINGLE_CHOICE: Non sapevo cosa fossero, Non mi sembravano utili, Non ho avuto occasione, Preferisco metodi tradizionali)
    - Jump to Q5 (skip experience depth - go straight to concerns)

  **Section 2: Work usage (adaptive depth)**
  - Q2: "Hai usato strumenti AI per il tuo lavoro legale?" (YES_NO)
    - If YES -> Q2a
    - If NO -> Q2d
  - Q2a: "Per quali attivita hai usato l'AI nel lavoro?" (MULTIPLE_CHOICE: Ricerca giuridica, Studio di documenti, Scrittura/redazione atti, Comunicazione con clienti, Organizzazione studio, Altro)
  - Q2b: "Come sta cambiando il tuo utilizzo dell'AI?" (SINGLE_CHOICE: Lo uso sempre di piu, Stabile, Lo uso meno di prima, Ho smesso di usarlo)
  - Q2c: "Quanto sei soddisfatto dei risultati ottenuti con l'AI?" (SINGLE_CHOICE: Per niente, Poco, Abbastanza, Molto)
    - All three continue to Q3
  - Q2d: "Cosa ti ha frenato dall'usare l'AI nel lavoro?" (MULTIPLE_CHOICE: Dubbi sulla riservatezza dei dati, Non saprei da dove iniziare, Timore di risultati inaffidabili, Non credo sia utile per il mio lavoro, Non ho avuto tempo di provare)
    - Jump to Q4 (skip satisfaction - go to concerns)

  **Section 3: Confidence**
  - Q3: "Come descriveresti il tuo livello di confidenza con gli strumenti AI?" (SINGLE_CHOICE: Principiante - li provo ma non mi fido dei risultati, Intermedio - li uso regolarmente per alcuni compiti, Avanzato - li integro nel mio flusso di lavoro quotidiano)

  **Section 4: Expectations**
  - Q4: "Cosa ti aspetti da questo corso?" (TEXT - open question)

  **Section 5: Concerns**
  - Q5: "Quali aspetti dell'AI ti preoccupano di piu nel contesto legale?" (MULTIPLE_CHOICE: Privacy e riservatezza dei dati dei clienti, Rischio di errori e allucinazioni, Implicazioni deontologiche, Impatto sulla professione a lungo termine, Dipendenza dalla tecnologia, Nessuna preoccupazione particolare)

  **Section 6: Course priorities**
  - Q6: "Su quali temi vorresti concentrarti durante il corso?" (RANKING top 3: Uso pratico degli strumenti AI, Rischi e limiti dell'AI, Aspetti deontologici, Protezione dei dati, Casi d'uso per avvocati, Scrivere prompt efficaci)

  **Branching implementation:**
  - Use `showCondition` for conditional visibility (same as Phase 1 pattern)
  - Use `nextQuestionId` at the OPTION level for answer-specific jumps (e.g., Q1 YES option does not set nextQuestionId so flow continues, Q1 NO option sets nextQuestionId to Q1b)
  - For Q1b -> Q5 skip: set `nextQuestionId: "q5-concerns"` on the Q1b question level (Question.nextQuestionId)
  - For Q2d -> Q4 skip: set `nextQuestionId: "q4-expectations"` on Q2d question level

  Question IDs should be descriptive: "q1-aware", "q1a-tools", "q1b-whynot-aware", "q2-work", "q2a-activities", "q2b-trend", "q2c-satisfaction", "q2d-barriers", "q3-confidence", "q4-expectations", "q5-concerns", "q6-priorities"

  After writing seed.ts, run `npx tsx prisma/seed.ts` to seed the database.
  </action>
  <verify>
  - `npx prisma db push` succeeds without errors
  - `npx tsx prisma/seed.ts` completes and reports all questions created
  - Check question count in seed output matches expected (12 questions)
  </verify>
  <done>
  - Session model has coursePrompts and facilitatorNotes fields
  - Seed creates 12 Italian questions with branching logic (showCondition + nextQuestionId)
  - Three distinct paths exist: aware+working, aware+not-working, not-aware
  - TypeScript types updated with new Session fields and CoursePrompt type
  </done>
</task>

<task type="auto">
  <name>Task 2: Upgrade branching engine for nextQuestionId navigation</name>
  <files>src/store/quiz-store.ts, src/hooks/useQuiz.ts</files>
  <action>
  **Quiz store (src/store/quiz-store.ts) - upgrade `nextQuestion()`:**

  Current behavior: `nextQuestion` increments currentIndex and skips invisible questions (those failing showCondition). This works for simple conditional branching but does NOT support jumping to a specific question based on the selected answer.

  New behavior for `nextQuestion()`:
  1. Get current question and its answer
  2. Check if the selected answer's option has a `nextQuestionId` (option-level branching)
     - For SINGLE_CHOICE, YES_NO, PROFILE_SELECT: check the selected option's nextQuestionId
     - For MULTIPLE_CHOICE, TEXT, RANKING: no option-level branching (not applicable)
  3. If option has nextQuestionId -> find that question's index in the questions array and jump there
  4. Check if the current question itself has a `nextQuestionId` (question-level branching) -> jump there
  5. Otherwise, fall through to current behavior: increment and skip invisible questions

  Implementation detail for step 2:
  ```typescript
  const currentAnswer = answers[currentQuestion.id]
  let jumpToId: string | null = null

  // Check option-level nextQuestionId
  if (currentAnswer && "selectedOptionId" in currentAnswer && currentQuestion.options) {
    const selectedOption = (currentQuestion.options as QuestionOption[]).find(
      o => o.id === currentAnswer.selectedOptionId
    )
    if (selectedOption?.nextQuestionId) {
      jumpToId = selectedOption.nextQuestionId
    }
  }

  // Check question-level nextQuestionId
  if (!jumpToId && currentQuestion.nextQuestionId) {
    jumpToId = currentQuestion.nextQuestionId
  }

  // If we have a jump target, find its index
  if (jumpToId) {
    const targetIndex = questions.findIndex(q => q.id === jumpToId)
    if (targetIndex !== -1) {
      set({ currentIndex: targetIndex })
      // update server-side index too
      return
    }
  }

  // Fall through to existing scan-forward behavior
  ```

  **Important:** Import `QuestionOption` type in quiz-store.ts if not already imported.

  **Quiz store - upgrade `prevQuestion()`:**
  Keep current behavior (scan backward for visible questions). Going back should retrace the linear path, not reverse branching. This is already correct.

  **useQuiz hook (src/hooks/useQuiz.ts) - update visible questions:**
  The current `visibleQuestions` memo filters ALL questions by showCondition. This works because showCondition controls visibility. The branching via nextQuestionId controls NAVIGATION order, not visibility.

  However, `visibleQuestions.length` is used for the progress bar total. With branching, a user on the shortest path might see 7 questions but visibleQuestions shows 10 (because other branch questions also pass showCondition when unanswered).

  Fix: Track the actual path taken. Add a `questionPath` computed value to useQuiz that builds the ordered list of questions the user HAS seen or WILL see given current answers:

  ```typescript
  const questionPath = useMemo(() => {
    const path: Question[] = []
    let currentQ = questions[0]

    while (currentQ) {
      // Check if this question is visible
      if (!evaluateShowCondition(currentQ.showCondition, answers)) {
        // Skip invisible, move to next in order
        const nextIdx = questions.indexOf(currentQ) + 1
        currentQ = nextIdx < questions.length ? questions[nextIdx] : undefined
        continue
      }

      path.push(currentQ)

      // Determine next question
      const answer = answers[currentQ.id]
      let nextId: string | null = null

      // Check option-level jump
      if (answer && "selectedOptionId" in answer && currentQ.options) {
        const selectedOption = (currentQ.options as QuestionOption[]).find(
          o => o.id === (answer as SingleAnswerValue).selectedOptionId
        )
        if (selectedOption?.nextQuestionId) {
          nextId = selectedOption.nextQuestionId
        }
      }

      // Check question-level jump
      if (!nextId && currentQ.nextQuestionId) {
        nextId = currentQ.nextQuestionId
      }

      if (nextId) {
        currentQ = questions.find(q => q.id === nextId)
      } else {
        // Scan forward for next visible
        const currentIdx = questions.indexOf(currentQ)
        let nextIdx = currentIdx + 1
        while (nextIdx < questions.length) {
          if (evaluateShowCondition(questions[nextIdx].showCondition, answers)) {
            break
          }
          nextIdx++
        }
        currentQ = nextIdx < questions.length ? questions[nextIdx] : undefined
      }

      // Safety: prevent infinite loops
      if (path.length > questions.length) break
    }

    return path
  }, [questions, answers])
  ```

  Update the hook return to expose `questionPath` instead of `visibleQuestions` for progress calculation:
  - `progress` should use `questionPath.length` as total and count answered within path
  - `isLastQuestion` should check against `questionPath`
  - `currentVisibleIndex` should find position in `questionPath`
  - Keep `visibleQuestions` exported for backward compatibility but use `questionPath` for all progress/navigation calculations

  Import `QuestionOption` and `SingleAnswerValue` types in useQuiz.ts.
  </action>
  <verify>
  - `npm run build` completes without TypeScript errors
  - Manual test: Start quiz, answer Q1 with "No" -> should jump to Q1b, then to Q5 (skipping work section)
  - Manual test: Start quiz, answer Q1 "Yes" -> Q1a -> Q2 -> (if Yes) Q2a,Q2b,Q2c -> Q3 -> Q4 -> Q5 -> Q6
  - Progress bar shows correct count for the user's actual path
  </verify>
  <done>
  - nextQuestion() supports option-level nextQuestionId jumps
  - nextQuestion() supports question-level nextQuestionId jumps
  - Progress bar reflects actual path length (not total questions)
  - Three distinct paths work: not-aware (short), aware-not-working (medium), aware-working (full)
  - Build passes with no TypeScript errors
  </done>
</task>

</tasks>

<verification>
1. `npx prisma db push` - schema applies cleanly
2. `npx tsx prisma/seed.ts` - seeds 12 questions with branching
3. `npm run build` - no TypeScript errors
4. `npm run dev` - start app and test:
   - Path A (not aware): Q1(No) -> Q1b -> Q5 -> Q6 (4 questions)
   - Path B (aware, not working): Q1(Yes) -> Q1a -> Q2(No) -> Q2d -> Q4 -> Q5 -> Q6 (7 questions)
   - Path C (aware, working): Q1(Yes) -> Q1a -> Q2(Yes) -> Q2a -> Q2b -> Q2c -> Q3 -> Q4 -> Q5 -> Q6 (10 questions)
5. Progress bar shows correct total for each path
</verification>

<success_criteria>
- 12 Italian questions seeded with adaptive branching across 3 distinct paths
- Branching engine handles both option-level and question-level nextQuestionId
- Progress bar reflects actual user path length
- Build passes, app runs without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-adaptive-logic-results/02-01-SUMMARY.md`
</output>
